WorkingWithKevinJames.README
============================

This README serves as a brief introduction to working with me. It definitely
doesn't replace getting to know each other through 1-on-1's, day-to-day chats,
etc., but hopefully it can serve as a starting point to help build our
relationship more quickly.

I am very interested in self-improvement -- constructive feedback on this
document or on anything else is always welcome and appreciated. If you have any
suggestions on how I can improve, or if you notice any discrepancy between this
README and my behaviour, **please** tell me!

Communication
-------------

Despite my best efforts to minimize them, I've somehow ended up with nearly a
dozen different communication channels to manage. I do my best to keep
up-to-date with them all, but it's inevitable that some will fall through the
cracks. For any unscheduled communication, my preference is the following:

- face-to-face/video for **high bandwidth** communication. If another
  communication channel seems to be producing confusion or misunderstandings,
  moving to this channel is a good way to fix that. Also fantastic for
  rubber-ducking and brainstorming.

- emails for **low priority or long-term** messaging. I would love to move away
  from email entirely, but I've long-since accepted that isn't going to happen
  any time soon. In the meantime, I make sure to check email regularly and keep
  up-to-date, but will often prefer to treat it as an "action item" and respond
  via some channel I think is more relevant to the problem at hand (eg. have a
  conversation, set a meeting, fix a bug...).

- Slack for **everything else**. I believe that -- so long as you we put some
  effort into ensuring we keep channels fairly organized and each person
  configures their notifications to fit their preferences -- Slack is a great
  solution for anything from **urgent, high-priority** issues to **general
  RFCs** to **long-lived info tidbits** and everything in-between. If you Slack
  me, you can generally expect a very quick turnaround time; I work best while
  juggling multiple things at once and *enjoy* context-switching to respond
  quickly.

Availability
------------

I am still working on my work-life balance. In the meantime, that means I am
often online after-hours or even on the weekends. I do not expect you to be. If
I message you outside of ~9 to ~5 (in your timezone!), I'm not expecting a
response -- it can wait until the next (work)day.

I am often "in the office" between 10AM and 6PM, with some slight variation
depending on bus routes, sleep schedule, and "getting one last thing done
before I head out".

Process and Development
-----------------------

I've worked with and without Agile, Scrum, Waterfall, and blah-blah-blah other
systems. At the end of the day, I care less about the framework and much more
about the following:

- I value speed of development -- including proactive efforts such as
  writing/improving tests, refactoring legacy systems, and dissemination of
  knowledge either through pairing or improving documentation.

- I value learning -- exploring new ideas, trying new methods/libraries/sytems,
  and being willing to discard and prune exploratory code once we settle into
  something which works. Re-exploring the status quo semi-regularly, especially
  with regards to legacy systems and pain points, is a fantastic way to build a
  reliable and easy-to-work-with system.

- I value our time as employees -- automating our workflows, simplifying our
  systems, pruning unnecessary meetings, etc. are all fantastic ways to give us
  the time to *actually do our jobs* rather than talk about doing them.

- I value doing things right rather than quick -- cutting corners now is an
  excellent way to have more work to do next week.

Code Reviews
^^^^^^^^^^^^

I am a firm believer in code reviews and believe they are one of the top ways
in which we as engineers grow and learn new things. I love doing code reviews,
especially when the feature under review is something I am not experienced with
-- that means we (hopefully) both get to learn something new!

Here's a few of my thoughts around code reviews:

- often, review comments can lead to interesting conversations as we explore
  new options, alternate libraries, and differing methodology choices. I am
  more than happy to move any conversation to Slack or some other form of
  communication -- in fact, I've found some of the best new ideas have come
  from conversations like that!

- I believe strongly in code consistency, since it makes future maintenance
  significantly easier. I try to set up tools for the vast majority of these
  sorts of issues, but will often comment with "nitpicks". If I begin any
  review comment with "nitpick: ", you are welcome to avoid addressing that
  issue if you believe it's worth getting the code out more quickly. These
  things should be addressed at some point, but there's a trade-off between
  "perfect" and "fast"; "good enough" is a worthy goal.

- if we've chatted about it already, or it's a "one-liner", or if its
  config-only, it might be a candidate for going "straight to master". Use your
  best judgement! Despite what I said above, there's a time-and-place for
  inundating each other with PRs.

Feedback
--------

I love optimizing and improving systems, especially including myself and my own
processes. I promise you cannot offend my by giving honest feedback and I love
to hear it.

If there's something you liked and want to seem more of, something you thought
I could do better, something you think I completely screwed up, or anything
else, I want to hear it. If you think it's something I wouldn't want to hear,
I'd love feedback on why you feel that way.

If you're not comfortable giving this feedback to me directly, you can feel
free to give it to someone above me to-be relayed anonymously.

Let me know if and how you would like to receive any feedback to me -- I'm more
than happy to return the favour!

One-Liners
----------

Various one-liners embodying my favorite axioms and architectural principles:

* Design for 10x scale. Re-design when you get to 20x.
* Reuse components. Corollary: build reusable components.
* Use *boring* software. Alpha is exciting but easily breakable.
* *Use* boring software. `Not Invented Here`_ is a poison.
* You either have a single source of truth or multiple sources of lies.
* Similarly, but to be clear: you either have a single schema or many implicit
  ones defined throughout your codebase.
* Do it decently the first time. The second try will be when it catches fire.
* Migrations should be easy. Plan for disaster, build for failure, lower the
  risk.

Your Philosophies
-----------------

Though I've written a lot here about working with me, I'm much more interested
in how you'd like me to work with you -- if there's anything I could be doing
to better work with you, let's chat!

.. _Not Invented Here: https://en.wikipedia.org/wiki/Not_invented_here
